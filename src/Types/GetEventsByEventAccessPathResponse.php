<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: get_with_proof.proto

namespace Types;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>types.GetEventsByEventAccessPathResponse</code>
 */
class GetEventsByEventAccessPathResponse extends \Google\Protobuf\Internal\Message
{
    /**
     * Returns an event and proof of each of the events in the request. The first
     * element of proofs will be the closest to `start_event_seq_num`.
     *
     * Generated from protobuf field <code>repeated .types.EventWithProof events_with_proof = 1;</code>
     */
    private $events_with_proof;
    /**
     * If the number of events returned is less than `limit` for an ascending
     * query or if start_event_seq_num > the latest seq_num for a descending
     * query,  returns the state of the account containing the given access path
     * in the latest state. This allows the client to verify that there are in
     * fact no extra events.
     * The LedgerInfoWithSignatures which is on the main
     * UpdateToLatestLedgerResponse can be used to validate this.
     *
     * Generated from protobuf field <code>.types.AccountStateWithProof proof_of_latest_event = 2;</code>
     */
    private $proof_of_latest_event = null;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Types\EventWithProof[]|\Google\Protobuf\Internal\RepeatedField $events_with_proof
     *           Returns an event and proof of each of the events in the request. The first
     *           element of proofs will be the closest to `start_event_seq_num`.
     *     @type \Types\AccountStateWithProof $proof_of_latest_event
     *           If the number of events returned is less than `limit` for an ascending
     *           query or if start_event_seq_num > the latest seq_num for a descending
     *           query,  returns the state of the account containing the given access path
     *           in the latest state. This allows the client to verify that there are in
     *           fact no extra events.
     *           The LedgerInfoWithSignatures which is on the main
     *           UpdateToLatestLedgerResponse can be used to validate this.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\GetWithProof::initOnce();
        parent::__construct($data);
    }

    /**
     * Returns an event and proof of each of the events in the request. The first
     * element of proofs will be the closest to `start_event_seq_num`.
     *
     * Generated from protobuf field <code>repeated .types.EventWithProof events_with_proof = 1;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getEventsWithProof()
    {
        return $this->events_with_proof;
    }

    /**
     * Returns an event and proof of each of the events in the request. The first
     * element of proofs will be the closest to `start_event_seq_num`.
     *
     * Generated from protobuf field <code>repeated .types.EventWithProof events_with_proof = 1;</code>
     * @param \Types\EventWithProof[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setEventsWithProof($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Types\EventWithProof::class);
        $this->events_with_proof = $arr;

        return $this;
    }

    /**
     * If the number of events returned is less than `limit` for an ascending
     * query or if start_event_seq_num > the latest seq_num for a descending
     * query,  returns the state of the account containing the given access path
     * in the latest state. This allows the client to verify that there are in
     * fact no extra events.
     * The LedgerInfoWithSignatures which is on the main
     * UpdateToLatestLedgerResponse can be used to validate this.
     *
     * Generated from protobuf field <code>.types.AccountStateWithProof proof_of_latest_event = 2;</code>
     * @return \Types\AccountStateWithProof
     */
    public function getProofOfLatestEvent()
    {
        return $this->proof_of_latest_event;
    }

    /**
     * If the number of events returned is less than `limit` for an ascending
     * query or if start_event_seq_num > the latest seq_num for a descending
     * query,  returns the state of the account containing the given access path
     * in the latest state. This allows the client to verify that there are in
     * fact no extra events.
     * The LedgerInfoWithSignatures which is on the main
     * UpdateToLatestLedgerResponse can be used to validate this.
     *
     * Generated from protobuf field <code>.types.AccountStateWithProof proof_of_latest_event = 2;</code>
     * @param \Types\AccountStateWithProof $var
     * @return $this
     */
    public function setProofOfLatestEvent($var)
    {
        GPBUtil::checkMessage($var, \Types\AccountStateWithProof::class);
        $this->proof_of_latest_event = $var;

        return $this;
    }

}

